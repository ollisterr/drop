/**
 * Generated by orval v6.3.0 üç∫
 * Do not edit manually.
 * Drop API
 * The OpenAPI schema for drop.energy
 * OpenAPI spec version: 0.1.0
 */
import {
  useQuery,
  useMutation,
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
} from "react-query";
import type {
  ApartmentGroupsPlural,
  HTTPValidationError,
  GetApartmentGroupsGetParams,
  ApartmentGroupsOutput,
  ApartmentGroupsIn,
  CountModel,
  CountApartmentGroupsCountGetParams,
  IdsApartmentGroupsIdsGet200,
  IdsApartmentGroupsIdsGetParams,
  NewApartmentGroupsNewGet200,
  ReferencesModel,
  SchemaApartmentGroupsSchemaGet200,
  ApartmentGroupsOptional,
  ApartmentPlural,
  GetApartmentGetParams,
  ApartmentOutput,
  ApartmentIn,
  CountApartmentCountGetParams,
  IdsApartmentIdsGet200,
  IdsApartmentIdsGetParams,
  NewApartmentNewGet200,
  SchemaApartmentSchemaGet200,
  ApartmentOptional,
  GroupPlural,
  GetGroupGetParams,
  GroupOutput,
  GroupIn,
  CountGroupCountGetParams,
  IdsGroupIdsGet200,
  IdsGroupIdsGetParams,
  NewGroupNewGet200,
  SchemaGroupSchemaGet200,
  GroupOptional,
  MeasurementPlural,
  GetMeasurementGetParams,
  MeasurementOutput,
  MeasurementIn,
  CountMeasurementCountGetParams,
  IdsMeasurementIdsGet200,
  IdsMeasurementIdsGetParams,
  NewMeasurementNewGet200,
  SchemaMeasurementSchemaGet200,
  MeasurementOptional,
} from ".././model";
import { customInstance } from ".././axios";

type AsyncReturnType<T extends (...args: any) => Promise<any>> = T extends (
  ...args: any
) => Promise<infer R>
  ? R
  : any;

/**
 * Returns all rows matching the given query.
 * @summary Get
 */
export const getApartmentGroupsGet = (params?: GetApartmentGroupsGetParams) => {
  return customInstance<ApartmentGroupsPlural>({
    url: `/apartment-groups`,
    method: "get",
    params,
  });
};

export const getGetApartmentGroupsGetQueryKey = (
  params?: GetApartmentGroupsGetParams
) => [`/apartment-groups`, ...(params ? [params] : [])];

export const useGetApartmentGroupsGet = <
  TData = AsyncReturnType<typeof getApartmentGroupsGet>,
  TError = HTTPValidationError
>(
  params?: GetApartmentGroupsGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getApartmentGroupsGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApartmentGroupsGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof getApartmentGroupsGet>> =
    () => getApartmentGroupsGet(params);

  const query = useQuery<
    AsyncReturnType<typeof getApartmentGroupsGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Create a new row in the table.
 * @summary Post
 */
export const postApartmentGroupsPost = (
  apartmentGroupsIn: ApartmentGroupsIn
) => {
  return customInstance<ApartmentGroupsOutput>({
    url: `/apartment-groups`,
    method: "post",
    data: apartmentGroupsIn,
  });
};

export const usePostApartmentGroupsPost = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof postApartmentGroupsPost>,
    TError,
    { data: ApartmentGroupsIn },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof postApartmentGroupsPost>,
    { data: ApartmentGroupsIn }
  > = (props) => {
    const { data } = props || {};

    return postApartmentGroupsPost(data);
  };

  return useMutation<
    AsyncReturnType<typeof postApartmentGroupsPost>,
    TError,
    { data: ApartmentGroupsIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns the number of rows matching the given query.
 * @summary Count
 */
export const countApartmentGroupsCountGet = (
  params?: CountApartmentGroupsCountGetParams
) => {
  return customInstance<CountModel>({
    url: `/apartment-groups/count`,
    method: "get",
    params,
  });
};

export const getCountApartmentGroupsCountGetQueryKey = (
  params?: CountApartmentGroupsCountGetParams
) => [`/apartment-groups/count`, ...(params ? [params] : [])];

export const useCountApartmentGroupsCountGet = <
  TData = AsyncReturnType<typeof countApartmentGroupsCountGet>,
  TError = HTTPValidationError
>(
  params?: CountApartmentGroupsCountGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof countApartmentGroupsCountGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getCountApartmentGroupsCountGetQueryKey(params);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof countApartmentGroupsCountGet>
  > = () => countApartmentGroupsCountGet(params);

  const query = useQuery<
    AsyncReturnType<typeof countApartmentGroupsCountGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a mapping of row IDs to a readable representation.
 * @summary Ids
 */
export const idsApartmentGroupsIdsGet = (
  params?: IdsApartmentGroupsIdsGetParams
) => {
  return customInstance<IdsApartmentGroupsIdsGet200>({
    url: `/apartment-groups/ids`,
    method: "get",
    params,
  });
};

export const getIdsApartmentGroupsIdsGetQueryKey = (
  params?: IdsApartmentGroupsIdsGetParams
) => [`/apartment-groups/ids`, ...(params ? [params] : [])];

export const useIdsApartmentGroupsIdsGet = <
  TData = AsyncReturnType<typeof idsApartmentGroupsIdsGet>,
  TError = HTTPValidationError
>(
  params?: IdsApartmentGroupsIdsGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof idsApartmentGroupsIdsGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getIdsApartmentGroupsIdsGetQueryKey(params);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof idsApartmentGroupsIdsGet>
  > = () => idsApartmentGroupsIdsGet(params);

  const query = useQuery<
    AsyncReturnType<typeof idsApartmentGroupsIdsGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns all of the default values for a new row,
but doesn't save it.
 * @summary New
 */
export const newApartmentGroupsNewGet = () => {
  return customInstance<NewApartmentGroupsNewGet200>({
    url: `/apartment-groups/new`,
    method: "get",
  });
};

export const getNewApartmentGroupsNewGetQueryKey = () => [
  `/apartment-groups/new`,
];

export const useNewApartmentGroupsNewGet = <
  TData = AsyncReturnType<typeof newApartmentGroupsNewGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof newApartmentGroupsNewGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getNewApartmentGroupsNewGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof newApartmentGroupsNewGet>
  > = () => newApartmentGroupsNewGet();

  const query = useQuery<
    AsyncReturnType<typeof newApartmentGroupsNewGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a list of objects showing relationships with other tables.
 * @summary References
 */
export const referencesApartmentGroupsReferencesGet = () => {
  return customInstance<ReferencesModel>({
    url: `/apartment-groups/references`,
    method: "get",
  });
};

export const getReferencesApartmentGroupsReferencesGetQueryKey = () => [
  `/apartment-groups/references`,
];

export const useReferencesApartmentGroupsReferencesGet = <
  TData = AsyncReturnType<typeof referencesApartmentGroupsReferencesGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof referencesApartmentGroupsReferencesGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ??
    getReferencesApartmentGroupsReferencesGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof referencesApartmentGroupsReferencesGet>
  > = () => referencesApartmentGroupsReferencesGet();

  const query = useQuery<
    AsyncReturnType<typeof referencesApartmentGroupsReferencesGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns the JSON schema for the given table.
 * @summary Schema
 */
export const schemaApartmentGroupsSchemaGet = () => {
  return customInstance<SchemaApartmentGroupsSchemaGet200>({
    url: `/apartment-groups/schema`,
    method: "get",
  });
};

export const getSchemaApartmentGroupsSchemaGetQueryKey = () => [
  `/apartment-groups/schema`,
];

export const useSchemaApartmentGroupsSchemaGet = <
  TData = AsyncReturnType<typeof schemaApartmentGroupsSchemaGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof schemaApartmentGroupsSchemaGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getSchemaApartmentGroupsSchemaGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof schemaApartmentGroupsSchemaGet>
  > = () => schemaApartmentGroupsSchemaGet();

  const query = useQuery<
    AsyncReturnType<typeof schemaApartmentGroupsSchemaGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Delete a single row from the table.
 * @summary Delete Single
 */
export const deleteSingleApartmentGroupsRowIdDelete = (rowid: number) => {
  return customInstance<unknown>({
    url: `/apartment-groups/${rowid}`,
    method: "delete",
  });
};

export const useDeleteSingleApartmentGroupsRowIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof deleteSingleApartmentGroupsRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof deleteSingleApartmentGroupsRowIdDelete>,
    { rowid: number }
  > = (props) => {
    const { rowid } = props || {};

    return deleteSingleApartmentGroupsRowIdDelete(rowid);
  };

  return useMutation<
    AsyncReturnType<typeof deleteSingleApartmentGroupsRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Retrieve a single row from the table.
 * @summary Get Single
 */
export const getSingleApartmentGroupsRowIdGet = (rowid: number) => {
  return customInstance<ApartmentGroupsOutput>({
    url: `/apartment-groups/${rowid}`,
    method: "get",
  });
};

export const getGetSingleApartmentGroupsRowIdGetQueryKey = (rowid: number) => [
  `/apartment-groups/${rowid}`,
];

export const useGetSingleApartmentGroupsRowIdGet = <
  TData = AsyncReturnType<typeof getSingleApartmentGroupsRowIdGet>,
  TError = HTTPValidationError
>(
  rowid: number,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getSingleApartmentGroupsRowIdGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSingleApartmentGroupsRowIdGetQueryKey(rowid);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof getSingleApartmentGroupsRowIdGet>
  > = () => getSingleApartmentGroupsRowIdGet(rowid);

  const query = useQuery<
    AsyncReturnType<typeof getSingleApartmentGroupsRowIdGet>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!rowid, ...queryOptions });

  return {
    queryKey,
    ...query,
  };
};

/**
 * Update a single row.
 * @summary Patch
 */
export const patchApartmentGroupsRowIdPatch = (
  rowid: number,
  apartmentGroupsOptional: ApartmentGroupsOptional
) => {
  return customInstance<ApartmentGroupsOutput>({
    url: `/apartment-groups/${rowid}`,
    method: "patch",
    data: apartmentGroupsOptional,
  });
};

export const usePatchApartmentGroupsRowIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof patchApartmentGroupsRowIdPatch>,
    TError,
    { rowid: number; data: ApartmentGroupsOptional },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof patchApartmentGroupsRowIdPatch>,
    { rowid: number; data: ApartmentGroupsOptional }
  > = (props) => {
    const { rowid, data } = props || {};

    return patchApartmentGroupsRowIdPatch(rowid, data);
  };

  return useMutation<
    AsyncReturnType<typeof patchApartmentGroupsRowIdPatch>,
    TError,
    { rowid: number; data: ApartmentGroupsOptional },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Insert or update a single row.
 * @summary Put
 */
export const putApartmentGroupsRowIdPut = (
  rowid: number,
  apartmentGroupsIn: ApartmentGroupsIn
) => {
  return customInstance<ApartmentGroupsOutput>({
    url: `/apartment-groups/${rowid}`,
    method: "put",
    data: apartmentGroupsIn,
  });
};

export const usePutApartmentGroupsRowIdPut = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof putApartmentGroupsRowIdPut>,
    TError,
    { rowid: number; data: ApartmentGroupsIn },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof putApartmentGroupsRowIdPut>,
    { rowid: number; data: ApartmentGroupsIn }
  > = (props) => {
    const { rowid, data } = props || {};

    return putApartmentGroupsRowIdPut(rowid, data);
  };

  return useMutation<
    AsyncReturnType<typeof putApartmentGroupsRowIdPut>,
    TError,
    { rowid: number; data: ApartmentGroupsIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns all rows matching the given query.
 * @summary Get
 */
export const getApartmentGet = (params?: GetApartmentGetParams) => {
  return customInstance<ApartmentPlural>({
    url: `/apartment`,
    method: "get",
    params,
  });
};

export const getGetApartmentGetQueryKey = (params?: GetApartmentGetParams) => [
  `/apartment`,
  ...(params ? [params] : []),
];

export const useGetApartmentGet = <
  TData = AsyncReturnType<typeof getApartmentGet>,
  TError = HTTPValidationError
>(
  params?: GetApartmentGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getApartmentGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getGetApartmentGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof getApartmentGet>> = () =>
    getApartmentGet(params);

  const query = useQuery<
    AsyncReturnType<typeof getApartmentGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Create a new row in the table.
 * @summary Post
 */
export const postApartmentPost = (apartmentIn: ApartmentIn) => {
  return customInstance<ApartmentOutput>({
    url: `/apartment`,
    method: "post",
    data: apartmentIn,
  });
};

export const usePostApartmentPost = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof postApartmentPost>,
    TError,
    { data: ApartmentIn },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof postApartmentPost>,
    { data: ApartmentIn }
  > = (props) => {
    const { data } = props || {};

    return postApartmentPost(data);
  };

  return useMutation<
    AsyncReturnType<typeof postApartmentPost>,
    TError,
    { data: ApartmentIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns the number of rows matching the given query.
 * @summary Count
 */
export const countApartmentCountGet = (
  params?: CountApartmentCountGetParams
) => {
  return customInstance<CountModel>({
    url: `/apartment/count`,
    method: "get",
    params,
  });
};

export const getCountApartmentCountGetQueryKey = (
  params?: CountApartmentCountGetParams
) => [`/apartment/count`, ...(params ? [params] : [])];

export const useCountApartmentCountGet = <
  TData = AsyncReturnType<typeof countApartmentCountGet>,
  TError = HTTPValidationError
>(
  params?: CountApartmentCountGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof countApartmentCountGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getCountApartmentCountGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof countApartmentCountGet>> =
    () => countApartmentCountGet(params);

  const query = useQuery<
    AsyncReturnType<typeof countApartmentCountGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a mapping of row IDs to a readable representation.
 * @summary Ids
 */
export const idsApartmentIdsGet = (params?: IdsApartmentIdsGetParams) => {
  return customInstance<IdsApartmentIdsGet200>({
    url: `/apartment/ids`,
    method: "get",
    params,
  });
};

export const getIdsApartmentIdsGetQueryKey = (
  params?: IdsApartmentIdsGetParams
) => [`/apartment/ids`, ...(params ? [params] : [])];

export const useIdsApartmentIdsGet = <
  TData = AsyncReturnType<typeof idsApartmentIdsGet>,
  TError = HTTPValidationError
>(
  params?: IdsApartmentIdsGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof idsApartmentIdsGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getIdsApartmentIdsGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof idsApartmentIdsGet>> =
    () => idsApartmentIdsGet(params);

  const query = useQuery<
    AsyncReturnType<typeof idsApartmentIdsGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns all of the default values for a new row,
but doesn't save it.
 * @summary New
 */
export const newApartmentNewGet = () => {
  return customInstance<NewApartmentNewGet200>({
    url: `/apartment/new`,
    method: "get",
  });
};

export const getNewApartmentNewGetQueryKey = () => [`/apartment/new`];

export const useNewApartmentNewGet = <
  TData = AsyncReturnType<typeof newApartmentNewGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof newApartmentNewGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getNewApartmentNewGetQueryKey();

  const queryFn: QueryFunction<AsyncReturnType<typeof newApartmentNewGet>> =
    () => newApartmentNewGet();

  const query = useQuery<
    AsyncReturnType<typeof newApartmentNewGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a list of objects showing relationships with other tables.
 * @summary References
 */
export const referencesApartmentReferencesGet = () => {
  return customInstance<ReferencesModel>({
    url: `/apartment/references`,
    method: "get",
  });
};

export const getReferencesApartmentReferencesGetQueryKey = () => [
  `/apartment/references`,
];

export const useReferencesApartmentReferencesGet = <
  TData = AsyncReturnType<typeof referencesApartmentReferencesGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof referencesApartmentReferencesGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getReferencesApartmentReferencesGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof referencesApartmentReferencesGet>
  > = () => referencesApartmentReferencesGet();

  const query = useQuery<
    AsyncReturnType<typeof referencesApartmentReferencesGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns the JSON schema for the given table.
 * @summary Schema
 */
export const schemaApartmentSchemaGet = () => {
  return customInstance<SchemaApartmentSchemaGet200>({
    url: `/apartment/schema`,
    method: "get",
  });
};

export const getSchemaApartmentSchemaGetQueryKey = () => [`/apartment/schema`];

export const useSchemaApartmentSchemaGet = <
  TData = AsyncReturnType<typeof schemaApartmentSchemaGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof schemaApartmentSchemaGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getSchemaApartmentSchemaGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof schemaApartmentSchemaGet>
  > = () => schemaApartmentSchemaGet();

  const query = useQuery<
    AsyncReturnType<typeof schemaApartmentSchemaGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Delete a single row from the table.
 * @summary Delete Single
 */
export const deleteSingleApartmentRowIdDelete = (rowid: number) => {
  return customInstance<unknown>({
    url: `/apartment/${rowid}`,
    method: "delete",
  });
};

export const useDeleteSingleApartmentRowIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof deleteSingleApartmentRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof deleteSingleApartmentRowIdDelete>,
    { rowid: number }
  > = (props) => {
    const { rowid } = props || {};

    return deleteSingleApartmentRowIdDelete(rowid);
  };

  return useMutation<
    AsyncReturnType<typeof deleteSingleApartmentRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Retrieve a single row from the table.
 * @summary Get Single
 */
export const getSingleApartmentRowIdGet = (rowid: number) => {
  return customInstance<ApartmentOutput>({
    url: `/apartment/${rowid}`,
    method: "get",
  });
};

export const getGetSingleApartmentRowIdGetQueryKey = (rowid: number) => [
  `/apartment/${rowid}`,
];

export const useGetSingleApartmentRowIdGet = <
  TData = AsyncReturnType<typeof getSingleApartmentRowIdGet>,
  TError = HTTPValidationError
>(
  rowid: number,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getSingleApartmentRowIdGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSingleApartmentRowIdGetQueryKey(rowid);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof getSingleApartmentRowIdGet>
  > = () => getSingleApartmentRowIdGet(rowid);

  const query = useQuery<
    AsyncReturnType<typeof getSingleApartmentRowIdGet>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!rowid, ...queryOptions });

  return {
    queryKey,
    ...query,
  };
};

/**
 * Update a single row.
 * @summary Patch
 */
export const patchApartmentRowIdPatch = (
  rowid: number,
  apartmentOptional: ApartmentOptional
) => {
  return customInstance<ApartmentOutput>({
    url: `/apartment/${rowid}`,
    method: "patch",
    data: apartmentOptional,
  });
};

export const usePatchApartmentRowIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof patchApartmentRowIdPatch>,
    TError,
    { rowid: number; data: ApartmentOptional },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof patchApartmentRowIdPatch>,
    { rowid: number; data: ApartmentOptional }
  > = (props) => {
    const { rowid, data } = props || {};

    return patchApartmentRowIdPatch(rowid, data);
  };

  return useMutation<
    AsyncReturnType<typeof patchApartmentRowIdPatch>,
    TError,
    { rowid: number; data: ApartmentOptional },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Insert or update a single row.
 * @summary Put
 */
export const putApartmentRowIdPut = (
  rowid: number,
  apartmentIn: ApartmentIn
) => {
  return customInstance<ApartmentOutput>({
    url: `/apartment/${rowid}`,
    method: "put",
    data: apartmentIn,
  });
};

export const usePutApartmentRowIdPut = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof putApartmentRowIdPut>,
    TError,
    { rowid: number; data: ApartmentIn },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof putApartmentRowIdPut>,
    { rowid: number; data: ApartmentIn }
  > = (props) => {
    const { rowid, data } = props || {};

    return putApartmentRowIdPut(rowid, data);
  };

  return useMutation<
    AsyncReturnType<typeof putApartmentRowIdPut>,
    TError,
    { rowid: number; data: ApartmentIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns all rows matching the given query.
 * @summary Get
 */
export const getGroupGet = (params?: GetGroupGetParams) => {
  return customInstance<GroupPlural>({ url: `/group`, method: "get", params });
};

export const getGetGroupGetQueryKey = (params?: GetGroupGetParams) => [
  `/group`,
  ...(params ? [params] : []),
];

export const useGetGroupGet = <
  TData = AsyncReturnType<typeof getGroupGet>,
  TError = HTTPValidationError
>(
  params?: GetGroupGetParams,
  options?: {
    query?: UseQueryOptions<AsyncReturnType<typeof getGroupGet>, TError, TData>;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getGetGroupGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof getGroupGet>> = () =>
    getGroupGet(params);

  const query = useQuery<AsyncReturnType<typeof getGroupGet>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  );

  return {
    queryKey,
    ...query,
  };
};

/**
 * Create a new row in the table.
 * @summary Post
 */
export const postGroupPost = (groupIn: GroupIn) => {
  return customInstance<GroupOutput>({
    url: `/group`,
    method: "post",
    data: groupIn,
  });
};

export const usePostGroupPost = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof postGroupPost>,
    TError,
    { data: GroupIn },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof postGroupPost>,
    { data: GroupIn }
  > = (props) => {
    const { data } = props || {};

    return postGroupPost(data);
  };

  return useMutation<
    AsyncReturnType<typeof postGroupPost>,
    TError,
    { data: GroupIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns the number of rows matching the given query.
 * @summary Count
 */
export const countGroupCountGet = (params?: CountGroupCountGetParams) => {
  return customInstance<CountModel>({
    url: `/group/count`,
    method: "get",
    params,
  });
};

export const getCountGroupCountGetQueryKey = (
  params?: CountGroupCountGetParams
) => [`/group/count`, ...(params ? [params] : [])];

export const useCountGroupCountGet = <
  TData = AsyncReturnType<typeof countGroupCountGet>,
  TError = HTTPValidationError
>(
  params?: CountGroupCountGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof countGroupCountGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getCountGroupCountGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof countGroupCountGet>> =
    () => countGroupCountGet(params);

  const query = useQuery<
    AsyncReturnType<typeof countGroupCountGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a mapping of row IDs to a readable representation.
 * @summary Ids
 */
export const idsGroupIdsGet = (params?: IdsGroupIdsGetParams) => {
  return customInstance<IdsGroupIdsGet200>({
    url: `/group/ids`,
    method: "get",
    params,
  });
};

export const getIdsGroupIdsGetQueryKey = (params?: IdsGroupIdsGetParams) => [
  `/group/ids`,
  ...(params ? [params] : []),
];

export const useIdsGroupIdsGet = <
  TData = AsyncReturnType<typeof idsGroupIdsGet>,
  TError = HTTPValidationError
>(
  params?: IdsGroupIdsGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof idsGroupIdsGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getIdsGroupIdsGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof idsGroupIdsGet>> = () =>
    idsGroupIdsGet(params);

  const query = useQuery<AsyncReturnType<typeof idsGroupIdsGet>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  );

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns all of the default values for a new row,
but doesn't save it.
 * @summary New
 */
export const newGroupNewGet = () => {
  return customInstance<NewGroupNewGet200>({
    url: `/group/new`,
    method: "get",
  });
};

export const getNewGroupNewGetQueryKey = () => [`/group/new`];

export const useNewGroupNewGet = <
  TData = AsyncReturnType<typeof newGroupNewGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof newGroupNewGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getNewGroupNewGetQueryKey();

  const queryFn: QueryFunction<AsyncReturnType<typeof newGroupNewGet>> = () =>
    newGroupNewGet();

  const query = useQuery<AsyncReturnType<typeof newGroupNewGet>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  );

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a list of objects showing relationships with other tables.
 * @summary References
 */
export const referencesGroupReferencesGet = () => {
  return customInstance<ReferencesModel>({
    url: `/group/references`,
    method: "get",
  });
};

export const getReferencesGroupReferencesGetQueryKey = () => [
  `/group/references`,
];

export const useReferencesGroupReferencesGet = <
  TData = AsyncReturnType<typeof referencesGroupReferencesGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof referencesGroupReferencesGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getReferencesGroupReferencesGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof referencesGroupReferencesGet>
  > = () => referencesGroupReferencesGet();

  const query = useQuery<
    AsyncReturnType<typeof referencesGroupReferencesGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns the JSON schema for the given table.
 * @summary Schema
 */
export const schemaGroupSchemaGet = () => {
  return customInstance<SchemaGroupSchemaGet200>({
    url: `/group/schema`,
    method: "get",
  });
};

export const getSchemaGroupSchemaGetQueryKey = () => [`/group/schema`];

export const useSchemaGroupSchemaGet = <
  TData = AsyncReturnType<typeof schemaGroupSchemaGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof schemaGroupSchemaGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getSchemaGroupSchemaGetQueryKey();

  const queryFn: QueryFunction<AsyncReturnType<typeof schemaGroupSchemaGet>> =
    () => schemaGroupSchemaGet();

  const query = useQuery<
    AsyncReturnType<typeof schemaGroupSchemaGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Delete a single row from the table.
 * @summary Delete Single
 */
export const deleteSingleGroupRowIdDelete = (rowid: number) => {
  return customInstance<unknown>({ url: `/group/${rowid}`, method: "delete" });
};

export const useDeleteSingleGroupRowIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof deleteSingleGroupRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof deleteSingleGroupRowIdDelete>,
    { rowid: number }
  > = (props) => {
    const { rowid } = props || {};

    return deleteSingleGroupRowIdDelete(rowid);
  };

  return useMutation<
    AsyncReturnType<typeof deleteSingleGroupRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Retrieve a single row from the table.
 * @summary Get Single
 */
export const getSingleGroupRowIdGet = (rowid: number) => {
  return customInstance<GroupOutput>({ url: `/group/${rowid}`, method: "get" });
};

export const getGetSingleGroupRowIdGetQueryKey = (rowid: number) => [
  `/group/${rowid}`,
];

export const useGetSingleGroupRowIdGet = <
  TData = AsyncReturnType<typeof getSingleGroupRowIdGet>,
  TError = HTTPValidationError
>(
  rowid: number,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getSingleGroupRowIdGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSingleGroupRowIdGetQueryKey(rowid);

  const queryFn: QueryFunction<AsyncReturnType<typeof getSingleGroupRowIdGet>> =
    () => getSingleGroupRowIdGet(rowid);

  const query = useQuery<
    AsyncReturnType<typeof getSingleGroupRowIdGet>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!rowid, ...queryOptions });

  return {
    queryKey,
    ...query,
  };
};

/**
 * Update a single row.
 * @summary Patch
 */
export const patchGroupRowIdPatch = (
  rowid: number,
  groupOptional: GroupOptional
) => {
  return customInstance<GroupOutput>({
    url: `/group/${rowid}`,
    method: "patch",
    data: groupOptional,
  });
};

export const usePatchGroupRowIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof patchGroupRowIdPatch>,
    TError,
    { rowid: number; data: GroupOptional },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof patchGroupRowIdPatch>,
    { rowid: number; data: GroupOptional }
  > = (props) => {
    const { rowid, data } = props || {};

    return patchGroupRowIdPatch(rowid, data);
  };

  return useMutation<
    AsyncReturnType<typeof patchGroupRowIdPatch>,
    TError,
    { rowid: number; data: GroupOptional },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Insert or update a single row.
 * @summary Put
 */
export const putGroupRowIdPut = (rowid: number, groupIn: GroupIn) => {
  return customInstance<GroupOutput>({
    url: `/group/${rowid}`,
    method: "put",
    data: groupIn,
  });
};

export const usePutGroupRowIdPut = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof putGroupRowIdPut>,
    TError,
    { rowid: number; data: GroupIn },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof putGroupRowIdPut>,
    { rowid: number; data: GroupIn }
  > = (props) => {
    const { rowid, data } = props || {};

    return putGroupRowIdPut(rowid, data);
  };

  return useMutation<
    AsyncReturnType<typeof putGroupRowIdPut>,
    TError,
    { rowid: number; data: GroupIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns all rows matching the given query.
 * @summary Get
 */
export const getMeasurementGet = (params?: GetMeasurementGetParams) => {
  return customInstance<MeasurementPlural>({
    url: `/measurement`,
    method: "get",
    params,
  });
};

export const getGetMeasurementGetQueryKey = (
  params?: GetMeasurementGetParams
) => [`/measurement`, ...(params ? [params] : [])];

export const useGetMeasurementGet = <
  TData = AsyncReturnType<typeof getMeasurementGet>,
  TError = HTTPValidationError
>(
  params?: GetMeasurementGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getMeasurementGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMeasurementGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof getMeasurementGet>> =
    () => getMeasurementGet(params);

  const query = useQuery<
    AsyncReturnType<typeof getMeasurementGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Create a new row in the table.
 * @summary Post
 */
export const postMeasurementPost = (measurementIn: MeasurementIn) => {
  return customInstance<MeasurementOutput>({
    url: `/measurement`,
    method: "post",
    data: measurementIn,
  });
};

export const usePostMeasurementPost = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof postMeasurementPost>,
    TError,
    { data: MeasurementIn },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof postMeasurementPost>,
    { data: MeasurementIn }
  > = (props) => {
    const { data } = props || {};

    return postMeasurementPost(data);
  };

  return useMutation<
    AsyncReturnType<typeof postMeasurementPost>,
    TError,
    { data: MeasurementIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns the number of rows matching the given query.
 * @summary Count
 */
export const countMeasurementCountGet = (
  params?: CountMeasurementCountGetParams
) => {
  return customInstance<CountModel>({
    url: `/measurement/count`,
    method: "get",
    params,
  });
};

export const getCountMeasurementCountGetQueryKey = (
  params?: CountMeasurementCountGetParams
) => [`/measurement/count`, ...(params ? [params] : [])];

export const useCountMeasurementCountGet = <
  TData = AsyncReturnType<typeof countMeasurementCountGet>,
  TError = HTTPValidationError
>(
  params?: CountMeasurementCountGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof countMeasurementCountGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getCountMeasurementCountGetQueryKey(params);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof countMeasurementCountGet>
  > = () => countMeasurementCountGet(params);

  const query = useQuery<
    AsyncReturnType<typeof countMeasurementCountGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a mapping of row IDs to a readable representation.
 * @summary Ids
 */
export const idsMeasurementIdsGet = (params?: IdsMeasurementIdsGetParams) => {
  return customInstance<IdsMeasurementIdsGet200>({
    url: `/measurement/ids`,
    method: "get",
    params,
  });
};

export const getIdsMeasurementIdsGetQueryKey = (
  params?: IdsMeasurementIdsGetParams
) => [`/measurement/ids`, ...(params ? [params] : [])];

export const useIdsMeasurementIdsGet = <
  TData = AsyncReturnType<typeof idsMeasurementIdsGet>,
  TError = HTTPValidationError
>(
  params?: IdsMeasurementIdsGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof idsMeasurementIdsGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getIdsMeasurementIdsGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof idsMeasurementIdsGet>> =
    () => idsMeasurementIdsGet(params);

  const query = useQuery<
    AsyncReturnType<typeof idsMeasurementIdsGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns all of the default values for a new row,
but doesn't save it.
 * @summary New
 */
export const newMeasurementNewGet = () => {
  return customInstance<NewMeasurementNewGet200>({
    url: `/measurement/new`,
    method: "get",
  });
};

export const getNewMeasurementNewGetQueryKey = () => [`/measurement/new`];

export const useNewMeasurementNewGet = <
  TData = AsyncReturnType<typeof newMeasurementNewGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof newMeasurementNewGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getNewMeasurementNewGetQueryKey();

  const queryFn: QueryFunction<AsyncReturnType<typeof newMeasurementNewGet>> =
    () => newMeasurementNewGet();

  const query = useQuery<
    AsyncReturnType<typeof newMeasurementNewGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a list of objects showing relationships with other tables.
 * @summary References
 */
export const referencesMeasurementReferencesGet = () => {
  return customInstance<ReferencesModel>({
    url: `/measurement/references`,
    method: "get",
  });
};

export const getReferencesMeasurementReferencesGetQueryKey = () => [
  `/measurement/references`,
];

export const useReferencesMeasurementReferencesGet = <
  TData = AsyncReturnType<typeof referencesMeasurementReferencesGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof referencesMeasurementReferencesGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getReferencesMeasurementReferencesGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof referencesMeasurementReferencesGet>
  > = () => referencesMeasurementReferencesGet();

  const query = useQuery<
    AsyncReturnType<typeof referencesMeasurementReferencesGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns the JSON schema for the given table.
 * @summary Schema
 */
export const schemaMeasurementSchemaGet = () => {
  return customInstance<SchemaMeasurementSchemaGet200>({
    url: `/measurement/schema`,
    method: "get",
  });
};

export const getSchemaMeasurementSchemaGetQueryKey = () => [
  `/measurement/schema`,
];

export const useSchemaMeasurementSchemaGet = <
  TData = AsyncReturnType<typeof schemaMeasurementSchemaGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof schemaMeasurementSchemaGet>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getSchemaMeasurementSchemaGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof schemaMeasurementSchemaGet>
  > = () => schemaMeasurementSchemaGet();

  const query = useQuery<
    AsyncReturnType<typeof schemaMeasurementSchemaGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Delete a single row from the table.
 * @summary Delete Single
 */
export const deleteSingleMeasurementRowIdDelete = (rowid: number) => {
  return customInstance<unknown>({
    url: `/measurement/${rowid}`,
    method: "delete",
  });
};

export const useDeleteSingleMeasurementRowIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof deleteSingleMeasurementRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof deleteSingleMeasurementRowIdDelete>,
    { rowid: number }
  > = (props) => {
    const { rowid } = props || {};

    return deleteSingleMeasurementRowIdDelete(rowid);
  };

  return useMutation<
    AsyncReturnType<typeof deleteSingleMeasurementRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Retrieve a single row from the table.
 * @summary Get Single
 */
export const getSingleMeasurementRowIdGet = (rowid: number) => {
  return customInstance<MeasurementOutput>({
    url: `/measurement/${rowid}`,
    method: "get",
  });
};

export const getGetSingleMeasurementRowIdGetQueryKey = (rowid: number) => [
  `/measurement/${rowid}`,
];

export const useGetSingleMeasurementRowIdGet = <
  TData = AsyncReturnType<typeof getSingleMeasurementRowIdGet>,
  TError = HTTPValidationError
>(
  rowid: number,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getSingleMeasurementRowIdGet>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSingleMeasurementRowIdGetQueryKey(rowid);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof getSingleMeasurementRowIdGet>
  > = () => getSingleMeasurementRowIdGet(rowid);

  const query = useQuery<
    AsyncReturnType<typeof getSingleMeasurementRowIdGet>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!rowid, ...queryOptions });

  return {
    queryKey,
    ...query,
  };
};

/**
 * Update a single row.
 * @summary Patch
 */
export const patchMeasurementRowIdPatch = (
  rowid: number,
  measurementOptional: MeasurementOptional
) => {
  return customInstance<MeasurementOutput>({
    url: `/measurement/${rowid}`,
    method: "patch",
    data: measurementOptional,
  });
};

export const usePatchMeasurementRowIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof patchMeasurementRowIdPatch>,
    TError,
    { rowid: number; data: MeasurementOptional },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof patchMeasurementRowIdPatch>,
    { rowid: number; data: MeasurementOptional }
  > = (props) => {
    const { rowid, data } = props || {};

    return patchMeasurementRowIdPatch(rowid, data);
  };

  return useMutation<
    AsyncReturnType<typeof patchMeasurementRowIdPatch>,
    TError,
    { rowid: number; data: MeasurementOptional },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Insert or update a single row.
 * @summary Put
 */
export const putMeasurementRowIdPut = (
  rowid: number,
  measurementIn: MeasurementIn
) => {
  return customInstance<MeasurementOutput>({
    url: `/measurement/${rowid}`,
    method: "put",
    data: measurementIn,
  });
};

export const usePutMeasurementRowIdPut = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof putMeasurementRowIdPut>,
    TError,
    { rowid: number; data: MeasurementIn },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof putMeasurementRowIdPut>,
    { rowid: number; data: MeasurementIn }
  > = (props) => {
    const { rowid, data } = props || {};

    return putMeasurementRowIdPut(rowid, data);
  };

  return useMutation<
    AsyncReturnType<typeof putMeasurementRowIdPut>,
    TError,
    { rowid: number; data: MeasurementIn },
    TContext
  >(mutationFn, mutationOptions);
};
