/**
 * Generated by orval v6.3.0 üç∫
 * Do not edit manually.
 * Drop API
 * The OpenAPI schema for drop.energy
 * OpenAPI spec version: 0.1.0
 */
import axios, { AxiosRequestConfig, AxiosResponse } from "axios";
import {
  useQuery,
  useMutation,
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
} from "react-query";
import type {
  ApartmentGroupsPlural,
  HTTPValidationError,
  GetApartmentGroupsGetParams,
  ApartmentGroupsOutput,
  ApartmentGroupsIn,
  CountModel,
  CountApartmentGroupsCountGetParams,
  IdsApartmentGroupsIdsGet200,
  IdsApartmentGroupsIdsGetParams,
  NewApartmentGroupsNewGet200,
  ReferencesModel,
  SchemaApartmentGroupsSchemaGet200,
  ApartmentGroupsOptional,
  ApartmentPlural,
  GetApartmentGetParams,
  ApartmentOutput,
  ApartmentIn,
  CountApartmentCountGetParams,
  IdsApartmentIdsGet200,
  IdsApartmentIdsGetParams,
  NewApartmentNewGet200,
  SchemaApartmentSchemaGet200,
  ApartmentOptional,
  GroupPlural,
  GetGroupGetParams,
  GroupOutput,
  GroupIn,
  CountGroupCountGetParams,
  IdsGroupIdsGet200,
  IdsGroupIdsGetParams,
  NewGroupNewGet200,
  SchemaGroupSchemaGet200,
  GroupOptional,
  MeasurementPlural,
  GetMeasurementGetParams,
  MeasurementOutput,
  MeasurementIn,
  CountMeasurementCountGetParams,
  IdsMeasurementIdsGet200,
  IdsMeasurementIdsGetParams,
  NewMeasurementNewGet200,
  SchemaMeasurementSchemaGet200,
  MeasurementOptional,
} from ".././model";

type AsyncReturnType<T extends (...args: any) => Promise<any>> = T extends (
  ...args: any
) => Promise<infer R>
  ? R
  : any;

/**
 * Returns all rows matching the given query.
 * @summary Get
 */
export const getApartmentGroupsGet = (
  params?: GetApartmentGroupsGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApartmentGroupsPlural>> => {
  return axios.get(`/apartment-groups`, {
    params,
    ...options,
  });
};

export const getGetApartmentGroupsGetQueryKey = (
  params?: GetApartmentGroupsGetParams
) => [`/apartment-groups`, ...(params ? [params] : [])];

export const useGetApartmentGroupsGet = <
  TData = AsyncReturnType<typeof getApartmentGroupsGet>,
  TError = HTTPValidationError
>(
  params?: GetApartmentGroupsGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getApartmentGroupsGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApartmentGroupsGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof getApartmentGroupsGet>> =
    () => getApartmentGroupsGet(params, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof getApartmentGroupsGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Create a new row in the table.
 * @summary Post
 */
export const postApartmentGroupsPost = (
  apartmentGroupsIn: ApartmentGroupsIn,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApartmentGroupsOutput>> => {
  return axios.post(`/apartment-groups`, apartmentGroupsIn, options);
};

export const usePostApartmentGroupsPost = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof postApartmentGroupsPost>,
    TError,
    { data: ApartmentGroupsIn },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof postApartmentGroupsPost>,
    { data: ApartmentGroupsIn }
  > = (props) => {
    const { data } = props || {};

    return postApartmentGroupsPost(data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof postApartmentGroupsPost>,
    TError,
    { data: ApartmentGroupsIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns the number of rows matching the given query.
 * @summary Count
 */
export const countApartmentGroupsCountGet = (
  params?: CountApartmentGroupsCountGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<CountModel>> => {
  return axios.get(`/apartment-groups/count`, {
    params,
    ...options,
  });
};

export const getCountApartmentGroupsCountGetQueryKey = (
  params?: CountApartmentGroupsCountGetParams
) => [`/apartment-groups/count`, ...(params ? [params] : [])];

export const useCountApartmentGroupsCountGet = <
  TData = AsyncReturnType<typeof countApartmentGroupsCountGet>,
  TError = HTTPValidationError
>(
  params?: CountApartmentGroupsCountGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof countApartmentGroupsCountGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getCountApartmentGroupsCountGetQueryKey(params);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof countApartmentGroupsCountGet>
  > = () => countApartmentGroupsCountGet(params, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof countApartmentGroupsCountGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a mapping of row IDs to a readable representation.
 * @summary Ids
 */
export const idsApartmentGroupsIdsGet = (
  params?: IdsApartmentGroupsIdsGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<IdsApartmentGroupsIdsGet200>> => {
  return axios.get(`/apartment-groups/ids`, {
    params,
    ...options,
  });
};

export const getIdsApartmentGroupsIdsGetQueryKey = (
  params?: IdsApartmentGroupsIdsGetParams
) => [`/apartment-groups/ids`, ...(params ? [params] : [])];

export const useIdsApartmentGroupsIdsGet = <
  TData = AsyncReturnType<typeof idsApartmentGroupsIdsGet>,
  TError = HTTPValidationError
>(
  params?: IdsApartmentGroupsIdsGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof idsApartmentGroupsIdsGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getIdsApartmentGroupsIdsGetQueryKey(params);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof idsApartmentGroupsIdsGet>
  > = () => idsApartmentGroupsIdsGet(params, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof idsApartmentGroupsIdsGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns all of the default values for a new row,
but doesn't save it.
 * @summary New
 */
export const newApartmentGroupsNewGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<NewApartmentGroupsNewGet200>> => {
  return axios.get(`/apartment-groups/new`, options);
};

export const getNewApartmentGroupsNewGetQueryKey = () => [
  `/apartment-groups/new`,
];

export const useNewApartmentGroupsNewGet = <
  TData = AsyncReturnType<typeof newApartmentGroupsNewGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof newApartmentGroupsNewGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getNewApartmentGroupsNewGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof newApartmentGroupsNewGet>
  > = () => newApartmentGroupsNewGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof newApartmentGroupsNewGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a list of objects showing relationships with other tables.
 * @summary References
 */
export const referencesApartmentGroupsReferencesGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ReferencesModel>> => {
  return axios.get(`/apartment-groups/references`, options);
};

export const getReferencesApartmentGroupsReferencesGetQueryKey = () => [
  `/apartment-groups/references`,
];

export const useReferencesApartmentGroupsReferencesGet = <
  TData = AsyncReturnType<typeof referencesApartmentGroupsReferencesGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof referencesApartmentGroupsReferencesGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ??
    getReferencesApartmentGroupsReferencesGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof referencesApartmentGroupsReferencesGet>
  > = () => referencesApartmentGroupsReferencesGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof referencesApartmentGroupsReferencesGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns the JSON schema for the given table.
 * @summary Schema
 */
export const schemaApartmentGroupsSchemaGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<SchemaApartmentGroupsSchemaGet200>> => {
  return axios.get(`/apartment-groups/schema`, options);
};

export const getSchemaApartmentGroupsSchemaGetQueryKey = () => [
  `/apartment-groups/schema`,
];

export const useSchemaApartmentGroupsSchemaGet = <
  TData = AsyncReturnType<typeof schemaApartmentGroupsSchemaGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof schemaApartmentGroupsSchemaGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getSchemaApartmentGroupsSchemaGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof schemaApartmentGroupsSchemaGet>
  > = () => schemaApartmentGroupsSchemaGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof schemaApartmentGroupsSchemaGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Delete a single row from the table.
 * @summary Delete Single
 */
export const deleteSingleApartmentGroupsRowIdDelete = (
  rowid: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.delete(`/apartment-groups/${rowid}`, options);
};

export const useDeleteSingleApartmentGroupsRowIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof deleteSingleApartmentGroupsRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof deleteSingleApartmentGroupsRowIdDelete>,
    { rowid: number }
  > = (props) => {
    const { rowid } = props || {};

    return deleteSingleApartmentGroupsRowIdDelete(rowid, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof deleteSingleApartmentGroupsRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Retrieve a single row from the table.
 * @summary Get Single
 */
export const getSingleApartmentGroupsRowIdGet = (
  rowid: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApartmentGroupsOutput>> => {
  return axios.get(`/apartment-groups/${rowid}`, options);
};

export const getGetSingleApartmentGroupsRowIdGetQueryKey = (rowid: number) => [
  `/apartment-groups/${rowid}`,
];

export const useGetSingleApartmentGroupsRowIdGet = <
  TData = AsyncReturnType<typeof getSingleApartmentGroupsRowIdGet>,
  TError = HTTPValidationError
>(
  rowid: number,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getSingleApartmentGroupsRowIdGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSingleApartmentGroupsRowIdGetQueryKey(rowid);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof getSingleApartmentGroupsRowIdGet>
  > = () => getSingleApartmentGroupsRowIdGet(rowid, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof getSingleApartmentGroupsRowIdGet>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!rowid, ...queryOptions });

  return {
    queryKey,
    ...query,
  };
};

/**
 * Update a single row.
 * @summary Patch
 */
export const patchApartmentGroupsRowIdPatch = (
  rowid: number,
  apartmentGroupsOptional: ApartmentGroupsOptional,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApartmentGroupsOutput>> => {
  return axios.patch(
    `/apartment-groups/${rowid}`,
    apartmentGroupsOptional,
    options
  );
};

export const usePatchApartmentGroupsRowIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof patchApartmentGroupsRowIdPatch>,
    TError,
    { rowid: number; data: ApartmentGroupsOptional },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof patchApartmentGroupsRowIdPatch>,
    { rowid: number; data: ApartmentGroupsOptional }
  > = (props) => {
    const { rowid, data } = props || {};

    return patchApartmentGroupsRowIdPatch(rowid, data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof patchApartmentGroupsRowIdPatch>,
    TError,
    { rowid: number; data: ApartmentGroupsOptional },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Insert or update a single row.
 * @summary Put
 */
export const putApartmentGroupsRowIdPut = (
  rowid: number,
  apartmentGroupsIn: ApartmentGroupsIn,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApartmentGroupsOutput>> => {
  return axios.put(`/apartment-groups/${rowid}`, apartmentGroupsIn, options);
};

export const usePutApartmentGroupsRowIdPut = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof putApartmentGroupsRowIdPut>,
    TError,
    { rowid: number; data: ApartmentGroupsIn },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof putApartmentGroupsRowIdPut>,
    { rowid: number; data: ApartmentGroupsIn }
  > = (props) => {
    const { rowid, data } = props || {};

    return putApartmentGroupsRowIdPut(rowid, data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof putApartmentGroupsRowIdPut>,
    TError,
    { rowid: number; data: ApartmentGroupsIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns all rows matching the given query.
 * @summary Get
 */
export const getApartmentGet = (
  params?: GetApartmentGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApartmentPlural>> => {
  return axios.get(`/apartment`, {
    params,
    ...options,
  });
};

export const getGetApartmentGetQueryKey = (params?: GetApartmentGetParams) => [
  `/apartment`,
  ...(params ? [params] : []),
];

export const useGetApartmentGet = <
  TData = AsyncReturnType<typeof getApartmentGet>,
  TError = HTTPValidationError
>(
  params?: GetApartmentGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getApartmentGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getGetApartmentGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof getApartmentGet>> = () =>
    getApartmentGet(params, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof getApartmentGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Create a new row in the table.
 * @summary Post
 */
export const postApartmentPost = (
  apartmentIn: ApartmentIn,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApartmentOutput>> => {
  return axios.post(`/apartment`, apartmentIn, options);
};

export const usePostApartmentPost = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof postApartmentPost>,
    TError,
    { data: ApartmentIn },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof postApartmentPost>,
    { data: ApartmentIn }
  > = (props) => {
    const { data } = props || {};

    return postApartmentPost(data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof postApartmentPost>,
    TError,
    { data: ApartmentIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns the number of rows matching the given query.
 * @summary Count
 */
export const countApartmentCountGet = (
  params?: CountApartmentCountGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<CountModel>> => {
  return axios.get(`/apartment/count`, {
    params,
    ...options,
  });
};

export const getCountApartmentCountGetQueryKey = (
  params?: CountApartmentCountGetParams
) => [`/apartment/count`, ...(params ? [params] : [])];

export const useCountApartmentCountGet = <
  TData = AsyncReturnType<typeof countApartmentCountGet>,
  TError = HTTPValidationError
>(
  params?: CountApartmentCountGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof countApartmentCountGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getCountApartmentCountGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof countApartmentCountGet>> =
    () => countApartmentCountGet(params, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof countApartmentCountGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a mapping of row IDs to a readable representation.
 * @summary Ids
 */
export const idsApartmentIdsGet = (
  params?: IdsApartmentIdsGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<IdsApartmentIdsGet200>> => {
  return axios.get(`/apartment/ids`, {
    params,
    ...options,
  });
};

export const getIdsApartmentIdsGetQueryKey = (
  params?: IdsApartmentIdsGetParams
) => [`/apartment/ids`, ...(params ? [params] : [])];

export const useIdsApartmentIdsGet = <
  TData = AsyncReturnType<typeof idsApartmentIdsGet>,
  TError = HTTPValidationError
>(
  params?: IdsApartmentIdsGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof idsApartmentIdsGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getIdsApartmentIdsGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof idsApartmentIdsGet>> =
    () => idsApartmentIdsGet(params, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof idsApartmentIdsGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns all of the default values for a new row,
but doesn't save it.
 * @summary New
 */
export const newApartmentNewGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<NewApartmentNewGet200>> => {
  return axios.get(`/apartment/new`, options);
};

export const getNewApartmentNewGetQueryKey = () => [`/apartment/new`];

export const useNewApartmentNewGet = <
  TData = AsyncReturnType<typeof newApartmentNewGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof newApartmentNewGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getNewApartmentNewGetQueryKey();

  const queryFn: QueryFunction<AsyncReturnType<typeof newApartmentNewGet>> =
    () => newApartmentNewGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof newApartmentNewGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a list of objects showing relationships with other tables.
 * @summary References
 */
export const referencesApartmentReferencesGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ReferencesModel>> => {
  return axios.get(`/apartment/references`, options);
};

export const getReferencesApartmentReferencesGetQueryKey = () => [
  `/apartment/references`,
];

export const useReferencesApartmentReferencesGet = <
  TData = AsyncReturnType<typeof referencesApartmentReferencesGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof referencesApartmentReferencesGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getReferencesApartmentReferencesGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof referencesApartmentReferencesGet>
  > = () => referencesApartmentReferencesGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof referencesApartmentReferencesGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns the JSON schema for the given table.
 * @summary Schema
 */
export const schemaApartmentSchemaGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<SchemaApartmentSchemaGet200>> => {
  return axios.get(`/apartment/schema`, options);
};

export const getSchemaApartmentSchemaGetQueryKey = () => [`/apartment/schema`];

export const useSchemaApartmentSchemaGet = <
  TData = AsyncReturnType<typeof schemaApartmentSchemaGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof schemaApartmentSchemaGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getSchemaApartmentSchemaGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof schemaApartmentSchemaGet>
  > = () => schemaApartmentSchemaGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof schemaApartmentSchemaGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Delete a single row from the table.
 * @summary Delete Single
 */
export const deleteSingleApartmentRowIdDelete = (
  rowid: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.delete(`/apartment/${rowid}`, options);
};

export const useDeleteSingleApartmentRowIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof deleteSingleApartmentRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof deleteSingleApartmentRowIdDelete>,
    { rowid: number }
  > = (props) => {
    const { rowid } = props || {};

    return deleteSingleApartmentRowIdDelete(rowid, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof deleteSingleApartmentRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Retrieve a single row from the table.
 * @summary Get Single
 */
export const getSingleApartmentRowIdGet = (
  rowid: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApartmentOutput>> => {
  return axios.get(`/apartment/${rowid}`, options);
};

export const getGetSingleApartmentRowIdGetQueryKey = (rowid: number) => [
  `/apartment/${rowid}`,
];

export const useGetSingleApartmentRowIdGet = <
  TData = AsyncReturnType<typeof getSingleApartmentRowIdGet>,
  TError = HTTPValidationError
>(
  rowid: number,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getSingleApartmentRowIdGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSingleApartmentRowIdGetQueryKey(rowid);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof getSingleApartmentRowIdGet>
  > = () => getSingleApartmentRowIdGet(rowid, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof getSingleApartmentRowIdGet>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!rowid, ...queryOptions });

  return {
    queryKey,
    ...query,
  };
};

/**
 * Update a single row.
 * @summary Patch
 */
export const patchApartmentRowIdPatch = (
  rowid: number,
  apartmentOptional: ApartmentOptional,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApartmentOutput>> => {
  return axios.patch(`/apartment/${rowid}`, apartmentOptional, options);
};

export const usePatchApartmentRowIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof patchApartmentRowIdPatch>,
    TError,
    { rowid: number; data: ApartmentOptional },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof patchApartmentRowIdPatch>,
    { rowid: number; data: ApartmentOptional }
  > = (props) => {
    const { rowid, data } = props || {};

    return patchApartmentRowIdPatch(rowid, data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof patchApartmentRowIdPatch>,
    TError,
    { rowid: number; data: ApartmentOptional },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Insert or update a single row.
 * @summary Put
 */
export const putApartmentRowIdPut = (
  rowid: number,
  apartmentIn: ApartmentIn,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApartmentOutput>> => {
  return axios.put(`/apartment/${rowid}`, apartmentIn, options);
};

export const usePutApartmentRowIdPut = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof putApartmentRowIdPut>,
    TError,
    { rowid: number; data: ApartmentIn },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof putApartmentRowIdPut>,
    { rowid: number; data: ApartmentIn }
  > = (props) => {
    const { rowid, data } = props || {};

    return putApartmentRowIdPut(rowid, data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof putApartmentRowIdPut>,
    TError,
    { rowid: number; data: ApartmentIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns all rows matching the given query.
 * @summary Get
 */
export const getGroupGet = (
  params?: GetGroupGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<GroupPlural>> => {
  return axios.get(`/group`, {
    params,
    ...options,
  });
};

export const getGetGroupGetQueryKey = (params?: GetGroupGetParams) => [
  `/group`,
  ...(params ? [params] : []),
];

export const useGetGroupGet = <
  TData = AsyncReturnType<typeof getGroupGet>,
  TError = HTTPValidationError
>(
  params?: GetGroupGetParams,
  options?: {
    query?: UseQueryOptions<AsyncReturnType<typeof getGroupGet>, TError, TData>;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getGetGroupGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof getGroupGet>> = () =>
    getGroupGet(params, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof getGroupGet>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  );

  return {
    queryKey,
    ...query,
  };
};

/**
 * Create a new row in the table.
 * @summary Post
 */
export const postGroupPost = (
  groupIn: GroupIn,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<GroupOutput>> => {
  return axios.post(`/group`, groupIn, options);
};

export const usePostGroupPost = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof postGroupPost>,
    TError,
    { data: GroupIn },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof postGroupPost>,
    { data: GroupIn }
  > = (props) => {
    const { data } = props || {};

    return postGroupPost(data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof postGroupPost>,
    TError,
    { data: GroupIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns the number of rows matching the given query.
 * @summary Count
 */
export const countGroupCountGet = (
  params?: CountGroupCountGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<CountModel>> => {
  return axios.get(`/group/count`, {
    params,
    ...options,
  });
};

export const getCountGroupCountGetQueryKey = (
  params?: CountGroupCountGetParams
) => [`/group/count`, ...(params ? [params] : [])];

export const useCountGroupCountGet = <
  TData = AsyncReturnType<typeof countGroupCountGet>,
  TError = HTTPValidationError
>(
  params?: CountGroupCountGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof countGroupCountGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getCountGroupCountGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof countGroupCountGet>> =
    () => countGroupCountGet(params, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof countGroupCountGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a mapping of row IDs to a readable representation.
 * @summary Ids
 */
export const idsGroupIdsGet = (
  params?: IdsGroupIdsGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<IdsGroupIdsGet200>> => {
  return axios.get(`/group/ids`, {
    params,
    ...options,
  });
};

export const getIdsGroupIdsGetQueryKey = (params?: IdsGroupIdsGetParams) => [
  `/group/ids`,
  ...(params ? [params] : []),
];

export const useIdsGroupIdsGet = <
  TData = AsyncReturnType<typeof idsGroupIdsGet>,
  TError = HTTPValidationError
>(
  params?: IdsGroupIdsGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof idsGroupIdsGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getIdsGroupIdsGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof idsGroupIdsGet>> = () =>
    idsGroupIdsGet(params, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof idsGroupIdsGet>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  );

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns all of the default values for a new row,
but doesn't save it.
 * @summary New
 */
export const newGroupNewGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<NewGroupNewGet200>> => {
  return axios.get(`/group/new`, options);
};

export const getNewGroupNewGetQueryKey = () => [`/group/new`];

export const useNewGroupNewGet = <
  TData = AsyncReturnType<typeof newGroupNewGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof newGroupNewGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getNewGroupNewGetQueryKey();

  const queryFn: QueryFunction<AsyncReturnType<typeof newGroupNewGet>> = () =>
    newGroupNewGet(axiosOptions);

  const query = useQuery<AsyncReturnType<typeof newGroupNewGet>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  );

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a list of objects showing relationships with other tables.
 * @summary References
 */
export const referencesGroupReferencesGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ReferencesModel>> => {
  return axios.get(`/group/references`, options);
};

export const getReferencesGroupReferencesGetQueryKey = () => [
  `/group/references`,
];

export const useReferencesGroupReferencesGet = <
  TData = AsyncReturnType<typeof referencesGroupReferencesGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof referencesGroupReferencesGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getReferencesGroupReferencesGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof referencesGroupReferencesGet>
  > = () => referencesGroupReferencesGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof referencesGroupReferencesGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns the JSON schema for the given table.
 * @summary Schema
 */
export const schemaGroupSchemaGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<SchemaGroupSchemaGet200>> => {
  return axios.get(`/group/schema`, options);
};

export const getSchemaGroupSchemaGetQueryKey = () => [`/group/schema`];

export const useSchemaGroupSchemaGet = <
  TData = AsyncReturnType<typeof schemaGroupSchemaGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof schemaGroupSchemaGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getSchemaGroupSchemaGetQueryKey();

  const queryFn: QueryFunction<AsyncReturnType<typeof schemaGroupSchemaGet>> =
    () => schemaGroupSchemaGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof schemaGroupSchemaGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Delete a single row from the table.
 * @summary Delete Single
 */
export const deleteSingleGroupRowIdDelete = (
  rowid: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.delete(`/group/${rowid}`, options);
};

export const useDeleteSingleGroupRowIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof deleteSingleGroupRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof deleteSingleGroupRowIdDelete>,
    { rowid: number }
  > = (props) => {
    const { rowid } = props || {};

    return deleteSingleGroupRowIdDelete(rowid, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof deleteSingleGroupRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Retrieve a single row from the table.
 * @summary Get Single
 */
export const getSingleGroupRowIdGet = (
  rowid: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<GroupOutput>> => {
  return axios.get(`/group/${rowid}`, options);
};

export const getGetSingleGroupRowIdGetQueryKey = (rowid: number) => [
  `/group/${rowid}`,
];

export const useGetSingleGroupRowIdGet = <
  TData = AsyncReturnType<typeof getSingleGroupRowIdGet>,
  TError = HTTPValidationError
>(
  rowid: number,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getSingleGroupRowIdGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSingleGroupRowIdGetQueryKey(rowid);

  const queryFn: QueryFunction<AsyncReturnType<typeof getSingleGroupRowIdGet>> =
    () => getSingleGroupRowIdGet(rowid, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof getSingleGroupRowIdGet>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!rowid, ...queryOptions });

  return {
    queryKey,
    ...query,
  };
};

/**
 * Update a single row.
 * @summary Patch
 */
export const patchGroupRowIdPatch = (
  rowid: number,
  groupOptional: GroupOptional,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<GroupOutput>> => {
  return axios.patch(`/group/${rowid}`, groupOptional, options);
};

export const usePatchGroupRowIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof patchGroupRowIdPatch>,
    TError,
    { rowid: number; data: GroupOptional },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof patchGroupRowIdPatch>,
    { rowid: number; data: GroupOptional }
  > = (props) => {
    const { rowid, data } = props || {};

    return patchGroupRowIdPatch(rowid, data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof patchGroupRowIdPatch>,
    TError,
    { rowid: number; data: GroupOptional },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Insert or update a single row.
 * @summary Put
 */
export const putGroupRowIdPut = (
  rowid: number,
  groupIn: GroupIn,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<GroupOutput>> => {
  return axios.put(`/group/${rowid}`, groupIn, options);
};

export const usePutGroupRowIdPut = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof putGroupRowIdPut>,
    TError,
    { rowid: number; data: GroupIn },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof putGroupRowIdPut>,
    { rowid: number; data: GroupIn }
  > = (props) => {
    const { rowid, data } = props || {};

    return putGroupRowIdPut(rowid, data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof putGroupRowIdPut>,
    TError,
    { rowid: number; data: GroupIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns all rows matching the given query.
 * @summary Get
 */
export const getMeasurementGet = (
  params?: GetMeasurementGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<MeasurementPlural>> => {
  return axios.get(`/measurement`, {
    params,
    ...options,
  });
};

export const getGetMeasurementGetQueryKey = (
  params?: GetMeasurementGetParams
) => [`/measurement`, ...(params ? [params] : [])];

export const useGetMeasurementGet = <
  TData = AsyncReturnType<typeof getMeasurementGet>,
  TError = HTTPValidationError
>(
  params?: GetMeasurementGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getMeasurementGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMeasurementGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof getMeasurementGet>> =
    () => getMeasurementGet(params, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof getMeasurementGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Create a new row in the table.
 * @summary Post
 */
export const postMeasurementPost = (
  measurementIn: MeasurementIn,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<MeasurementOutput>> => {
  return axios.post(`/measurement`, measurementIn, options);
};

export const usePostMeasurementPost = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof postMeasurementPost>,
    TError,
    { data: MeasurementIn },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof postMeasurementPost>,
    { data: MeasurementIn }
  > = (props) => {
    const { data } = props || {};

    return postMeasurementPost(data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof postMeasurementPost>,
    TError,
    { data: MeasurementIn },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Returns the number of rows matching the given query.
 * @summary Count
 */
export const countMeasurementCountGet = (
  params?: CountMeasurementCountGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<CountModel>> => {
  return axios.get(`/measurement/count`, {
    params,
    ...options,
  });
};

export const getCountMeasurementCountGetQueryKey = (
  params?: CountMeasurementCountGetParams
) => [`/measurement/count`, ...(params ? [params] : [])];

export const useCountMeasurementCountGet = <
  TData = AsyncReturnType<typeof countMeasurementCountGet>,
  TError = HTTPValidationError
>(
  params?: CountMeasurementCountGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof countMeasurementCountGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getCountMeasurementCountGetQueryKey(params);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof countMeasurementCountGet>
  > = () => countMeasurementCountGet(params, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof countMeasurementCountGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a mapping of row IDs to a readable representation.
 * @summary Ids
 */
export const idsMeasurementIdsGet = (
  params?: IdsMeasurementIdsGetParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<IdsMeasurementIdsGet200>> => {
  return axios.get(`/measurement/ids`, {
    params,
    ...options,
  });
};

export const getIdsMeasurementIdsGetQueryKey = (
  params?: IdsMeasurementIdsGetParams
) => [`/measurement/ids`, ...(params ? [params] : [])];

export const useIdsMeasurementIdsGet = <
  TData = AsyncReturnType<typeof idsMeasurementIdsGet>,
  TError = HTTPValidationError
>(
  params?: IdsMeasurementIdsGetParams,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof idsMeasurementIdsGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getIdsMeasurementIdsGetQueryKey(params);

  const queryFn: QueryFunction<AsyncReturnType<typeof idsMeasurementIdsGet>> =
    () => idsMeasurementIdsGet(params, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof idsMeasurementIdsGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns all of the default values for a new row,
but doesn't save it.
 * @summary New
 */
export const newMeasurementNewGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<NewMeasurementNewGet200>> => {
  return axios.get(`/measurement/new`, options);
};

export const getNewMeasurementNewGetQueryKey = () => [`/measurement/new`];

export const useNewMeasurementNewGet = <
  TData = AsyncReturnType<typeof newMeasurementNewGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof newMeasurementNewGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey = queryOptions?.queryKey ?? getNewMeasurementNewGetQueryKey();

  const queryFn: QueryFunction<AsyncReturnType<typeof newMeasurementNewGet>> =
    () => newMeasurementNewGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof newMeasurementNewGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns a list of objects showing relationships with other tables.
 * @summary References
 */
export const referencesMeasurementReferencesGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ReferencesModel>> => {
  return axios.get(`/measurement/references`, options);
};

export const getReferencesMeasurementReferencesGetQueryKey = () => [
  `/measurement/references`,
];

export const useReferencesMeasurementReferencesGet = <
  TData = AsyncReturnType<typeof referencesMeasurementReferencesGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof referencesMeasurementReferencesGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getReferencesMeasurementReferencesGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof referencesMeasurementReferencesGet>
  > = () => referencesMeasurementReferencesGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof referencesMeasurementReferencesGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Returns the JSON schema for the given table.
 * @summary Schema
 */
export const schemaMeasurementSchemaGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<SchemaMeasurementSchemaGet200>> => {
  return axios.get(`/measurement/schema`, options);
};

export const getSchemaMeasurementSchemaGetQueryKey = () => [
  `/measurement/schema`,
];

export const useSchemaMeasurementSchemaGet = <
  TData = AsyncReturnType<typeof schemaMeasurementSchemaGet>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    AsyncReturnType<typeof schemaMeasurementSchemaGet>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getSchemaMeasurementSchemaGetQueryKey();

  const queryFn: QueryFunction<
    AsyncReturnType<typeof schemaMeasurementSchemaGet>
  > = () => schemaMeasurementSchemaGet(axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof schemaMeasurementSchemaGet>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query,
  };
};

/**
 * Delete a single row from the table.
 * @summary Delete Single
 */
export const deleteSingleMeasurementRowIdDelete = (
  rowid: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.delete(`/measurement/${rowid}`, options);
};

export const useDeleteSingleMeasurementRowIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof deleteSingleMeasurementRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof deleteSingleMeasurementRowIdDelete>,
    { rowid: number }
  > = (props) => {
    const { rowid } = props || {};

    return deleteSingleMeasurementRowIdDelete(rowid, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof deleteSingleMeasurementRowIdDelete>,
    TError,
    { rowid: number },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Retrieve a single row from the table.
 * @summary Get Single
 */
export const getSingleMeasurementRowIdGet = (
  rowid: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<MeasurementOutput>> => {
  return axios.get(`/measurement/${rowid}`, options);
};

export const getGetSingleMeasurementRowIdGetQueryKey = (rowid: number) => [
  `/measurement/${rowid}`,
];

export const useGetSingleMeasurementRowIdGet = <
  TData = AsyncReturnType<typeof getSingleMeasurementRowIdGet>,
  TError = HTTPValidationError
>(
  rowid: number,
  options?: {
    query?: UseQueryOptions<
      AsyncReturnType<typeof getSingleMeasurementRowIdGet>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options || {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSingleMeasurementRowIdGetQueryKey(rowid);

  const queryFn: QueryFunction<
    AsyncReturnType<typeof getSingleMeasurementRowIdGet>
  > = () => getSingleMeasurementRowIdGet(rowid, axiosOptions);

  const query = useQuery<
    AsyncReturnType<typeof getSingleMeasurementRowIdGet>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!rowid, ...queryOptions });

  return {
    queryKey,
    ...query,
  };
};

/**
 * Update a single row.
 * @summary Patch
 */
export const patchMeasurementRowIdPatch = (
  rowid: number,
  measurementOptional: MeasurementOptional,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<MeasurementOutput>> => {
  return axios.patch(`/measurement/${rowid}`, measurementOptional, options);
};

export const usePatchMeasurementRowIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof patchMeasurementRowIdPatch>,
    TError,
    { rowid: number; data: MeasurementOptional },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof patchMeasurementRowIdPatch>,
    { rowid: number; data: MeasurementOptional }
  > = (props) => {
    const { rowid, data } = props || {};

    return patchMeasurementRowIdPatch(rowid, data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof patchMeasurementRowIdPatch>,
    TError,
    { rowid: number; data: MeasurementOptional },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * Insert or update a single row.
 * @summary Put
 */
export const putMeasurementRowIdPut = (
  rowid: number,
  measurementIn: MeasurementIn,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<MeasurementOutput>> => {
  return axios.put(`/measurement/${rowid}`, measurementIn, options);
};

export const usePutMeasurementRowIdPut = <
  TError = HTTPValidationError,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AsyncReturnType<typeof putMeasurementRowIdPut>,
    TError,
    { rowid: number; data: MeasurementIn },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options || {};

  const mutationFn: MutationFunction<
    AsyncReturnType<typeof putMeasurementRowIdPut>,
    { rowid: number; data: MeasurementIn }
  > = (props) => {
    const { rowid, data } = props || {};

    return putMeasurementRowIdPut(rowid, data, axiosOptions);
  };

  return useMutation<
    AsyncReturnType<typeof putMeasurementRowIdPut>,
    TError,
    { rowid: number; data: MeasurementIn },
    TContext
  >(mutationFn, mutationOptions);
};
